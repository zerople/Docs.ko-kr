---
title: "데이터 보호 소개"
author: rick-anderson
description: 
keywords: ASP.NET Core
ms.author: riande
manager: wpickett
ms.date: 10/14/2016
ms.topic: article
ms.assetid: 4542cd37-b47c-454c-be19-d1b5810d67fe
ms.technology: aspnet
ms.prod: asp.net-core
uid: security/data-protection/introduction
ms.openlocfilehash: bcf1ce5a272a374c9605e50dee5c5fb27305527d
ms.sourcegitcommit: 0b6c8e6d81d2b3c161cd375036eecbace46a9707
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/11/2017
---
# <a name="introduction-to-data-protection"></a><span data-ttu-id="277af-103">데이터 보호 소개</span><span class="sxs-lookup"><span data-stu-id="277af-103">Introduction to Data Protection</span></span>

<span data-ttu-id="277af-104">웹 응용 프로그램은 종종 보안이 중요 한 데이터를 저장 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-104">Web applications often need to store security-sensitive data.</span></span> <span data-ttu-id="277af-105">Windows 데스크톱 응용 프로그램에 대 한 DPAPI를 제공 하지만 웹 응용 프로그램에 적합 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="277af-105">Windows provides DPAPI for desktop applications but this is unsuitable for web applications.</span></span> <span data-ttu-id="277af-106">ASP.NET Core 데이터 보호 스택의 개발자 키 관리 및 회전을 포함 한 데이터를 보호 사용할 수 있는 간단 하 고 사용 하기 쉬운 암호화 API를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-106">The ASP.NET Core data protection stack provide a simple, easy to use cryptographic API a developer can use to protect data, including key management and rotation.</span></span>

<span data-ttu-id="277af-107">ASP.NET Core 데이터 보호 스택의 장기적으로 대체도 충족 하도록 디자인 되었습니다는 <machineKey> asp.net에서 요소 1.x-4.x 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-107">The ASP.NET Core data protection stack is designed to serve as the long-term replacement for the <machineKey> element in ASP.NET 1.x - 4.x.</span></span> <span data-ttu-id="277af-108">사용 사례 최신 응용 프로그램 발생할 가능성이 높습니다. 대부분에 기본적으로 솔루션을 제공 하면서 다양 한 이전 암호화 스택의 단점을 해결 하기 위해 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="277af-108">It was designed to address many of the shortcomings of the old cryptographic stack while providing an out-of-the-box solution for the majority of use cases modern applications are likely to encounter.</span></span>

## <a name="problem-statement"></a><span data-ttu-id="277af-109">문제 설명</span><span class="sxs-lookup"><span data-stu-id="277af-109">Problem statement</span></span>

<span data-ttu-id="277af-110">전체 문제 설명 단일 문장에 간결 하 게 정의할 수 있습니다: 지 속성 메커니즘이 신뢰할 하지만 나중에 검색에 대 한 신뢰할 수 있는 정보를 유지 하 고 싶습니다.</span><span class="sxs-lookup"><span data-stu-id="277af-110">The overall problem statement can be succinctly stated in a single sentence: I need to persist trusted information for later retrieval, but I do not trust the persistence mechanism.</span></span> <span data-ttu-id="277af-111">웹 측면에서이 수로 작성할 수 "싶습니다 신뢰할 수 없는 클라이언트를 통해 왕복 신뢰할 수 있는 상태로."</span><span class="sxs-lookup"><span data-stu-id="277af-111">In web terms, this might be written as "I need to round-trip trusted state via an untrusted client."</span></span>

<span data-ttu-id="277af-112">이 정규 예제는 인증 쿠키 또는 bearer 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="277af-112">The canonical example of this is an authentication cookie or bearer token.</span></span> <span data-ttu-id="277af-113">서버 생성 하는 "I am Groot 및 xyz 권한이" 토큰 되며 클라이언트에 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-113">The server generates an "I am Groot and have xyz permissions" token and hands it to the client.</span></span> <span data-ttu-id="277af-114">미래의 특정 날짜에서 클라이언트는 서버에 다시 해당 토큰을 제시 합니다 되었지만 서버 몇 가지 종류의 보증 클라이언트 토큰을 위조 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="277af-114">At some future date the client will present that token back to the server, but the server needs some kind of assurance that the client hasn't forged the token.</span></span> <span data-ttu-id="277af-115">따라서 첫 번째 요구 사항: 신뢰성 (규칙 하위</span><span class="sxs-lookup"><span data-stu-id="277af-115">Thus the first requirement: authenticity (a.k.a.</span></span> <span data-ttu-id="277af-116">무결성, 변조 방지)입니다.</span><span class="sxs-lookup"><span data-stu-id="277af-116">integrity, tamper-proofing).</span></span>

<span data-ttu-id="277af-117">지속된 상태 서버에서 신뢰할 수, 이후 예상이 상태는 운영 환경과 관련 된 정보를 포함 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="277af-117">Since the persisted state is trusted by the server, we anticipate that this state might contain information that is specific to the operating environment.</span></span> <span data-ttu-id="277af-118">파일 경로, 사용 권한, 핸들 또는 다른 간접 참조의 형식 또는 다른 서버 관련 데이터가 몇 가지 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="277af-118">This could be in the form of a file path, a permission, a handle or other indirect reference, or some other piece of server-specific data.</span></span> <span data-ttu-id="277af-119">이러한 정보 일반적으로 공개 되지 않아야 신뢰할 수 없는 클라이언트를 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-119">Such information should generally not be disclosed to an untrusted client.</span></span> <span data-ttu-id="277af-120">따라서 두 번째 요구 사항: 기밀 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-120">Thus the second requirement: confidentiality.</span></span>

<span data-ttu-id="277af-121">마지막으로, 최신 응용 프로그램은 구성 요소화, 개괄적 이므로 개별 구성 요소는 시스템의 다른 구성 요소에 관계 없이이 시스템을 활용 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-121">Finally, since modern applications are componentized, what we've seen is that individual components will want to take advantage of this system without regard to other components in the system.</span></span> <span data-ttu-id="277af-122">예를 들어, 전달자 토큰 구성 요소를이 스택에 사용 하는 경우 사용할 수 있는 동일한 스택을 앤티 CSRF 메커니즘에서 문제 없이 작동 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-122">For instance, if a bearer token component is using this stack, it should operate without interference from an anti-CSRF mechanism that might also be using the same stack.</span></span> <span data-ttu-id="277af-123">따라서 최종 요구 사항: 격리 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-123">Thus the final requirement: isolation.</span></span>

<span data-ttu-id="277af-124">가능해 집니다 추가 제약 조건 요구 사항 범위를 좁히려면 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-124">We can provide further constraints in order to narrow the scope of our requirements.</span></span> <span data-ttu-id="277af-125">암호화 시스템 내에서 작동 하는 모든 서비스는 동일 하 게 신뢰할 수 있도록 하 고 데이터를 생성 하거나 우리의 직접 제어를 받는 서비스 외부에서 사용 하지 않아도 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-125">We assume that all services operating within the cryptosystem are equally trusted and that the data does not need to be generated or consumed outside of the services under our direct control.</span></span> <span data-ttu-id="277af-126">또한 작업은 가능한 한 빠르게 각 요청 웹 서비스에 한 번 이상 암호화는 시스템을 통해 이동할 수 있으므로 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-126">Furthermore, we require that operations are as fast as possible since each request to the web service might go through the cryptosystem one or more times.</span></span> <span data-ttu-id="277af-127">대칭 암호화 시나리오에 대 한 이상적인 있고, 등으로 필요할 때 한 번까지 비대칭 암호화 할인 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="277af-127">This makes symmetric cryptography ideal for our scenario, and we can discount asymmetric cryptography until such a time that it is needed.</span></span>

## <a name="design-philosophy"></a><span data-ttu-id="277af-128">디자인 원칙</span><span class="sxs-lookup"><span data-stu-id="277af-128">Design philosophy</span></span>

<span data-ttu-id="277af-129">기존 스택에 문제를 식별 하 여을 시작 했습니다.</span><span class="sxs-lookup"><span data-stu-id="277af-129">We started by identifying problems with the existing stack.</span></span> <span data-ttu-id="277af-130">했습니다, 서버가 기존 솔루션의 가로 조사 म 고 없는 기존 솔루션에 매우 둡니다 기능에 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-130">Once we had that, we surveyed the landscape of existing solutions and concluded that no existing solution quite had the capabilities we sought.</span></span> <span data-ttu-id="277af-131">몇 가지 원칙에 따라 솔루션을 다음 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="277af-131">We then engineered a solution based on several guiding principles.</span></span>

* <span data-ttu-id="277af-132">시스템 구성의 단순성을 제공 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-132">The system should offer simplicity of configuration.</span></span> <span data-ttu-id="277af-133">이상적으로 시스템은 구성이 필요 없는 개발자가 실행 중인 정확 수 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-133">Ideally the system would be zero-configuration and developers could hit the ground running.</span></span> <span data-ttu-id="277af-134">개발자가 특정 측면 (예: 키 저장소)를 구성 해야 하는 경우에서 고려 간단한 특정 구성을 제공 하기 위해 지정 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-134">In situations where developers need to configure a specific aspect (such as the key repository), consideration should be given to making those specific configurations simple.</span></span>

* <span data-ttu-id="277af-135">단순 소비자 용 API를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-135">Offer a simple consumer-facing API.</span></span> <span data-ttu-id="277af-136">Api를 잘못 사용 하기 쉽고를 잘못 사용 하기 어려운 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-136">The APIs should be easy to use correctly and difficult to use incorrectly.</span></span>

* <span data-ttu-id="277af-137">개발자 키 관리 원칙을 배울 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-137">Developers should not learn key management principles.</span></span> <span data-ttu-id="277af-138">알고리즘 선택 및 개발자의를 대신 하 여 키 수명 시스템이 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-138">The system should handle algorithm selection and key lifetime on the developer's behalf.</span></span> <span data-ttu-id="277af-139">이상적으로 개발자 원시 키 자료에 액세스를 권한이 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="277af-139">Ideally the developer should never even have access to the raw key material.</span></span>

* <span data-ttu-id="277af-140">가능 하면 저장 된 상태의 키를 보호 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-140">Keys should be protected at rest when possible.</span></span> <span data-ttu-id="277af-141">시스템에서는 적절 한 기본 보호 메커니즘을 파악 하 고 자동으로 적용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-141">The system should figure out an appropriate default protection mechanism and apply it automatically.</span></span>

<span data-ttu-id="277af-142">이러한 원칙을 염두 우리는 간단한 개발 [사용 하기 쉬운](using-data-protection.md) 데이터 보호 스택의 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-142">With these principles in mind we developed a simple, [easy to use](using-data-protection.md) data protection stack.</span></span>

<span data-ttu-id="277af-143">ASP.NET Core 데이터 보호 Api는 주로 없습니다 기밀 페이로드의 무한 지 속성.</span><span class="sxs-lookup"><span data-stu-id="277af-143">The ASP.NET Core data protection APIs are not primarily intended for indefinite persistence of confidential payloads.</span></span> <span data-ttu-id="277af-144">와 같은 다른 기술은 [Windows CNG DPAPI](https://msdn.microsoft.com/library/windows/desktop/hh706794%28v=vs.85%29.aspx) 및 [Azure 권한 관리](https://technet.microsoft.com/library/jj585024.aspx) 무한 저장소 시나리오에 보다 적합 한까지 강력한 키 관리 기능을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="277af-144">Other technologies like [Windows CNG DPAPI](https://msdn.microsoft.com/library/windows/desktop/hh706794%28v=vs.85%29.aspx) and [Azure Rights Management](https://technet.microsoft.com/library/jj585024.aspx) are more suited to the scenario of indefinite storage, and they have correspondingly strong key management capabilities.</span></span> <span data-ttu-id="277af-145">즉, 개발자는 ASP.NET Core 데이터 보호 Api를 사용 하 여 기밀 데이터의 장기 보호에 대 한 일은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="277af-145">That said, there is nothing prohibiting a developer from using the ASP.NET Core data protection APIs for long-term protection of confidential data.</span></span>

## <a name="audience"></a><span data-ttu-id="277af-146">대상 사용자</span><span class="sxs-lookup"><span data-stu-id="277af-146">Audience</span></span>

<span data-ttu-id="277af-147">데이터 보호 시스템 주 다섯 개의 패키지로으로 구분 됩니다.</span><span class="sxs-lookup"><span data-stu-id="277af-147">The data protection system is divided into five main packages.</span></span> <span data-ttu-id="277af-148">이러한 Api의 다양 한 측면에는 세 가지 주요 대상; 대상</span><span class="sxs-lookup"><span data-stu-id="277af-148">Various aspects of these APIs target three main audiences;</span></span>

1. <span data-ttu-id="277af-149">[소비자 Api 개요](consumer-apis/overview.md) 대상 프레임 워크 및 응용 프로그램 개발자.</span><span class="sxs-lookup"><span data-stu-id="277af-149">The [Consumer APIs Overview](consumer-apis/overview.md) target application and framework developers.</span></span>

   <span data-ttu-id="277af-150">"싶지 스택 작동 하는 방법에 대 한 또는 구성 된 방식에 대 한 자세한 내용을 알아보려면 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-150">"I don't want to learn about how the stack operates or about how it is configured.</span></span> <span data-ttu-id="277af-151">단순히 하겠습니다 일부로 작업을 수행에 단순한 방식으로 가능한 Api를 사용 하 여 성공적으로 확률이 높은. "</span><span class="sxs-lookup"><span data-stu-id="277af-151">I simply want to perform some operation in as simple a manner as possible with high probability of using the APIs successfully."</span></span>

2. <span data-ttu-id="277af-152">[구성 Api](configuration/overview.md) 응용 프로그램 개발자 및 시스템 관리자가 대상으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-152">The [configuration APIs](configuration/overview.md) target application developers and system administrators.</span></span>

   <span data-ttu-id="277af-153">"기본이 아닌 경로 또는 설정 내 환경 필요 함을 데이터 보호 시스템에 알려 하고자 합니다."</span><span class="sxs-lookup"><span data-stu-id="277af-153">"I need to tell the data protection system that my environment requires non-default paths or settings."</span></span>

3. <span data-ttu-id="277af-154">확장성 개발자는 Api 대상 사용자 지정 정책을 구현 하는 일을 담당 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-154">The extensibility APIs target developers in charge of implementing custom policy.</span></span> <span data-ttu-id="277af-155">이러한 Api에 드문 경우로 제한 되 고 개발자가 인식 하는 보안을 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-155">Usage of these APIs would be limited to rare situations and experienced, security aware developers.</span></span>

   <span data-ttu-id="277af-156">"하고자 실제로 고유 동작 요구 사항을 때문에 시스템 내에서 전체 구성 요소를 대체 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-156">"I need to replace an entire component within the system because I have truly unique behavioral requirements.</span></span> <span data-ttu-id="277af-157">하겠습니다 내 요구 사항을 충족 하는 플러그 인을 작성 하기 위해 API 화면의 프로토콜과 사용 하지 않는 부분에 알아보려면. "</span><span class="sxs-lookup"><span data-stu-id="277af-157">I am willing to learn uncommonly-used parts of the API surface in order to build a plugin that fulfills my requirements."</span></span>

## <a name="package-layout"></a><span data-ttu-id="277af-158">패키지 레이아웃</span><span class="sxs-lookup"><span data-stu-id="277af-158">Package Layout</span></span>

<span data-ttu-id="277af-159">데이터 보호 스택의 다섯 개의 패키지로 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="277af-159">The data protection stack consists of five packages.</span></span>

* <span data-ttu-id="277af-160">Microsoft.AspNetCore.DataProtection.Abstractions 기본 IDataProtectionProvider 및 IDataProtector 인터페이스를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-160">Microsoft.AspNetCore.DataProtection.Abstractions contains the basic IDataProtectionProvider and IDataProtector interfaces.</span></span> <span data-ttu-id="277af-161">또한 이러한 형식 (예: 오버 로드의 IDataProtector.Protect) 작업을 지원할 수 있는 유용한 확장 메서드를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-161">It also contains useful extension methods that can assist working with these types (e.g., overloads of IDataProtector.Protect).</span></span> <span data-ttu-id="277af-162">자세한 내용은 소비자 인터페이스 단원을 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="277af-162">See the consumer interfaces section for more information.</span></span> <span data-ttu-id="277af-163">다른 사람에 게는 데이터 보호 시스템 인스턴스화를 담당 하는 경우 단순히 Api를 사용 하는 Microsoft.AspNetCore.DataProtection.Abstractions 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-163">If somebody else is responsible for instantiating the data protection system and you are simply consuming the APIs, you'll want to reference Microsoft.AspNetCore.DataProtection.Abstractions.</span></span>

* <span data-ttu-id="277af-164">Microsoft.AspNetCore.DataProtection 핵심 암호화 작업, 키 관리, 구성 및 확장성을 포함 하 여 데이터 보호 시스템의 핵심 구현을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-164">Microsoft.AspNetCore.DataProtection contains the core implementation of the data protection system, including the core cryptographic operations, key management, configuration, and extensibility.</span></span> <span data-ttu-id="277af-165">데이터 보호 시스템 인스턴스화를 담당 하는 경우 (예:에 추가 IServiceCollection)를 수정 하거나 해당 동작을 확장 해야 Microsoft.AspNetCore.DataProtection 참조 또는 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-165">If you're responsible for instantiating the data protection system (e.g., adding it to an IServiceCollection) or modifying or extending its behavior, you'll want to reference Microsoft.AspNetCore.DataProtection.</span></span>

* <span data-ttu-id="277af-166">Microsoft.AspNetCore.DataProtection.Extensions는 개발자가 유용할 수 있지만 코어 패키지에 속해 있지 않습니다는 추가 Api를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-166">Microsoft.AspNetCore.DataProtection.Extensions contains additional APIs which developers might find useful but which don't belong in the core package.</span></span> <span data-ttu-id="277af-167">예를 들어,이 패키지는 간단한 "종속성 주입 설치 하지 않고도 특정 키 저장소 디렉터리를 가리키는 시스템 인스턴스화할" API (추가 정보)를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-167">For instance, this package contains a simple "instantiate the system pointing at a specific key storage directory with no dependency injection setup" API (more info).</span></span> <span data-ttu-id="277af-168">또한 보호 된 페이로드 (추가 정보)의 수명을 제한 하기 위한 확장 메서드를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-168">It also contains extension methods for limiting the lifetime of protected payloads (more info).</span></span>

* <span data-ttu-id="277af-169">Microsoft.AspNetCore.DataProtection.SystemWeb 리디렉션하려면 기존 ASP.NET 4.x 응용 프로그램에 설치할 수 있습니다는 <machineKey> 대신 새 데이터 보호 스택을 사용 하 여 작업 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-169">Microsoft.AspNetCore.DataProtection.SystemWeb can be installed into an existing ASP.NET 4.x application to redirect its <machineKey> operations to instead use the new data protection stack.</span></span> <span data-ttu-id="277af-170">참조 [호환성](compatibility/replacing-machinekey.md#compatibility-replacing-machinekey) 자세한 정보에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-170">See [compatibility](compatibility/replacing-machinekey.md#compatibility-replacing-machinekey) for more information.</span></span>

* <span data-ttu-id="277af-171">Microsoft.AspNetCore.Cryptography.KeyDerivation 루틴 해시 PBKDF2 암호의 구현을 제공 하 고 사용자 암호를 안전 하 게 처리 하는 데 필요한 시스템에서 사용 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="277af-171">Microsoft.AspNetCore.Cryptography.KeyDerivation provides an implementation of the PBKDF2 password hashing routine and can be used by systems which need to handle user passwords securely.</span></span> <span data-ttu-id="277af-172">참조 [암호 해시](consumer-apis/password-hashing.md) 자세한 정보에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="277af-172">See [Password Hashing](consumer-apis/password-hashing.md) for more information.</span></span>
